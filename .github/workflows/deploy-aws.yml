name: Deploy Frontend to AWS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
        default: 'production'
      region:
        description: 'AWS region'
        required: false
        default: 'us-east-1'
      backend_api_url:
        description: 'Backend API URL (e.g., https://api.example.com). Leave empty to auto-detect from backend stack.'
        required: false
        type: string
      backend_websocket_url:
        description: 'Backend WebSocket URL (e.g., wss://api.example.com). Leave empty to auto-detect.'
        required: false
        type: string
      wait_for_backend:
        description: 'Wait for backend deployment to complete before deploying frontend'
        required: false
        type: boolean
        default: true
  push:
    tags:
      - 'frontend-v*.*.*'

env:
  AWS_REGION: ${{ github.event.inputs.region || 'us-east-1' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || 'production' }}
  PROJECT_NAME: marketing-frontend

jobs:
  # Map frontend environment names to backend environment names
  map-environment:
    runs-on: ubuntu-latest
    outputs:
      backend_env: ${{ steps.map.outputs.backend_env }}
    steps:
      - id: map
        run: |
          case "${{ env.ENVIRONMENT }}" in
            development)
              echo "backend_env=dev" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "backend_env=stag" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "backend_env=prod" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "backend_env=${{ env.ENVIRONMENT }}" >> $GITHUB_OUTPUT
              ;;
          esac

  deploy:
    needs: map-environment
    name: Deploy Frontend to AWS

    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.PROJECT_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Wait for backend deployment (if requested)
        if: ${{ github.event.inputs.wait_for_backend == 'true' }}
        run: |
          BACKEND_STACK_NAME="marketing-tool-${{ needs.map-environment.outputs.backend_env }}"
          echo "Waiting for backend stack to be ready: $BACKEND_STACK_NAME"
          
          # Wait for stack to exist and be in a stable state
          MAX_WAIT=1800  # 30 minutes
          ELAPSED=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            if aws cloudformation describe-stacks --stack-name "$BACKEND_STACK_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
              STACK_STATUS=$(aws cloudformation describe-stacks \
                --stack-name "$BACKEND_STACK_NAME" \
                --query 'Stacks[0].StackStatus' \
                --output text \
                --region ${{ env.AWS_REGION }})
              
              echo "Backend stack status: $STACK_STATUS"
              
              if [[ "$STACK_STATUS" == "CREATE_COMPLETE" ]] || [[ "$STACK_STATUS" == "UPDATE_COMPLETE" ]]; then
                echo "âœ… Backend stack is ready!"
                break
              elif [[ "$STACK_STATUS" == *"FAILED"* ]] || [[ "$STACK_STATUS" == *"ROLLBACK"* ]]; then
                echo "âŒ Backend stack failed: $STACK_STATUS"
                exit 1
              fi
            else
              echo "Backend stack does not exist yet, waiting..."
            fi
            
            sleep 30
            ELAPSED=$((ELAPSED + 30))
          done
          
          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "âŒ Timeout waiting for backend stack"
            exit 1
          fi
          
          # Wait for backend ECS service to be stable
          BACKEND_CLUSTER="marketing-tool-${{ needs.map-environment.outputs.backend_env }}-cluster"
          BACKEND_SERVICE="marketing-tool-${{ needs.map-environment.outputs.backend_env }}-service"
          
          echo "Waiting for backend ECS service to be stable..."
          aws ecs wait services-stable \
            --cluster "$BACKEND_CLUSTER" \
            --services "$BACKEND_SERVICE" \
            --region ${{ env.AWS_REGION }} || echo "âš ï¸  Backend service check skipped (may not exist)"

      - name: Get backend URLs
        id: backend-urls
        run: |
          # Try to get backend URL from CloudFormation stack outputs first
          BACKEND_STACK_NAME="marketing-tool-${{ needs.map-environment.outputs.backend_env }}"
          
          if aws cloudformation describe-stacks --stack-name "$BACKEND_STACK_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
            # Get ALB URL from stack outputs
            ALB_URL=$(aws cloudformation describe-stacks \
              --stack-name "$BACKEND_STACK_NAME" \
              --query 'Stacks[0].Outputs[?OutputKey==`ALBURL`].OutputValue' \
              --output text \
              --region ${{ env.AWS_REGION }} || echo "")
            
            if [ -n "$ALB_URL" ]; then
              BACKEND_API_URL="https://$ALB_URL/api"
              BACKEND_WS_URL="wss://$ALB_URL/api"
              echo "âœ… Auto-detected backend URLs from stack outputs"
            fi
          fi
          
          # Use provided URLs or fall back to secrets
          BACKEND_API_URL="${BACKEND_API_URL:-${{ github.event.inputs.backend_api_url || secrets.BACKEND_API_URL }}}"
          BACKEND_WS_URL="${BACKEND_WS_URL:-${{ github.event.inputs.backend_websocket_url || secrets.BACKEND_WEBSOCKET_URL || format('wss://{0}', github.event.inputs.backend_api_url) }}}"
          
          if [ -z "$BACKEND_API_URL" ]; then
            echo "âŒ Backend API URL is required. Please provide it as input or set BACKEND_API_URL secret."
            exit 1
          fi
          
          echo "backend_api_url=$BACKEND_API_URL" >> $GITHUB_OUTPUT
          echo "backend_ws_url=$BACKEND_WS_URL" >> $GITHUB_OUTPUT
          echo "Using Backend API: $BACKEND_API_URL"
          echo "Using Backend WebSocket: $BACKEND_WS_URL"

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./deploy/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            NEXT_PUBLIC_BACKEND_API_BASE_URL=${{ steps.backend-urls.outputs.backend_api_url }}
            NEXT_PUBLIC_BACKEND_WEBSOCKET_URL=${{ steps.backend-urls.outputs.backend_ws_url }}

      - name: Get ECR repository URI
        id: ecr-uri
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.PROJECT_NAME }}:latest"
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "ECR URI: $ECR_URI"

      - name: Deploy to AWS using CloudFormation
        env:
          BACKEND_API_URL: ${{ steps.backend-urls.outputs.backend_api_url }}
          BACKEND_WEBSOCKET_URL: ${{ steps.backend-urls.outputs.backend_ws_url }}
          DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
          CERTIFICATE_ARN: ${{ secrets.CERTIFICATE_ARN }}
          HOSTED_ZONE_ID: ${{ secrets.HOSTED_ZONE_ID }}
        run: |
          cd deploy
          chmod +x deploy.sh

          # Create temporary parameters file
          cat > /tmp/params.json << EOF
          [
            {
              "ParameterKey": "EnvironmentName",
              "ParameterValue": "${{ env.ENVIRONMENT }}"
            },
            {
              "ParameterKey": "ContainerImage",
              "ParameterValue": "${{ steps.ecr-uri.outputs.ecr_uri }}"
            },
            {
              "ParameterKey": "BackendApiUrl",
              "ParameterValue": "$BACKEND_API_URL"
            },
            {
              "ParameterKey": "BackendWebSocketUrl",
              "ParameterValue": "$BACKEND_WEBSOCKET_URL"
            },
            {
              "ParameterKey": "CertificateArn",
              "ParameterValue": "${CERTIFICATE_ARN:-}"
            },
            {
              "ParameterKey": "DomainName",
              "ParameterValue": "${DOMAIN_NAME:-}"
            },
            {
              "ParameterKey": "HostedZoneId",
              "ParameterValue": "${HOSTED_ZONE_ID:-}"
            }
          ]
          EOF

          # Deploy using CloudFormation
          STACK_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}"
          
          if aws cloudformation describe-stacks --stack-name "$STACK_NAME" --region ${{ env.AWS_REGION }} &> /dev/null; then
            echo "Stack exists, updating..."
            aws cloudformation update-stack \
              --stack-name "$STACK_NAME" \
              --template-body file://cloudformation-template.yaml \
              --parameters file:///tmp/params.json \
              --capabilities CAPABILITY_IAM \
              --region ${{ env.AWS_REGION }} || true
            
            aws cloudformation wait stack-update-complete \
              --stack-name "$STACK_NAME" \
              --region ${{ env.AWS_REGION }}
          else
            echo "Stack does not exist, creating..."
            aws cloudformation create-stack \
              --stack-name "$STACK_NAME" \
              --template-body file://cloudformation-template.yaml \
              --parameters file:///tmp/params.json \
              --capabilities CAPABILITY_IAM \
              --region ${{ env.AWS_REGION }}
            
            aws cloudformation wait stack-create-complete \
              --stack-name "$STACK_NAME" \
              --region ${{ env.AWS_REGION }}
          fi

      - name: Update ECS service
        run: |
          CLUSTER_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-cluster"
          SERVICE_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-service"

          echo "Updating ECS service: $SERVICE_NAME in cluster: $CLUSTER_NAME"
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }} || echo "Service update skipped (may not exist yet)"

          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --region ${{ env.AWS_REGION }} || echo "Service stabilization check skipped"

      - name: Get deployment info
        id: deployment-info
        run: |
          STACK_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}"

          echo "Fetching stack outputs..."
          WEBSITE_URL=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --query 'Stacks[0].Outputs[?OutputKey==`WebsiteURL`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }} || echo "")

          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name $STACK_NAME \
            --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }} || echo "")

          echo "website_url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT

      - name: Health check
        run: |
          WEBSITE_URL="${{ steps.deployment-info.outputs.website_url }}"
          ALB_DNS="${{ steps.deployment-info.outputs.alb_dns }}"
          
          # Use website URL if available, otherwise use ALB DNS
          CHECK_URL="${WEBSITE_URL:-http://$ALB_DNS}"

          if [ -n "$CHECK_URL" ]; then
            echo "Performing health check on: $CHECK_URL"

            # Wait for service to be ready
            sleep 30

            # Retry health check up to 10 times
            for i in {1..10}; do
              if curl -f -s "$CHECK_URL" > /dev/null; then
                echo "âœ… Health check passed!"
                exit 0
              else
                echo "â³ Attempt $i/10 failed, retrying in 10s..."
                sleep 10
              fi
            done

            echo "âŒ Health check failed after 10 attempts"
            exit 1
          else
            echo "âš ï¸  URL not found, skipping health check"
          fi

      - name: Create deployment summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸš€ Frontend AWS Deployment Summary

          **Environment:** ${{ env.ENVIRONMENT }}
          **Region:** ${{ env.AWS_REGION }}
          **Stack:** ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}

          ### ðŸ“¦ Deployment Details
          - **Image Tags:** \`${{ steps.meta.outputs.tags }}\`
          - **ECR Repository:** \`${{ steps.ecr-uri.outputs.ecr_uri }}\`
          - **Backend API:** ${{ steps.backend-urls.outputs.backend_api_url }}
          - **Website URL:** ${{ steps.deployment-info.outputs.website_url }}

          ### ðŸ”— Quick Links
          - [CloudFormation Console](https://console.aws.amazon.com/cloudformation/home?region=${{ env.AWS_REGION }}#/stacks)
          - [ECS Console](https://console.aws.amazon.com/ecs/home?region=${{ env.AWS_REGION }}#/clusters)
          - [Frontend Application](${{ steps.deployment-info.outputs.website_url }})
          EOF

      - name: Notify on failure
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo "Check the logs above for details."
          echo "Stack: ${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}"
          echo "Region: ${{ env.AWS_REGION }}"

